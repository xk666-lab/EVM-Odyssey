# 代码规范

## **遵循代码规范的目的与好处**

- **提高代码可读性 (Improve Code Readability)**
  - 让其他开发者（以及未来的你）能更快地理解代码的逻辑和意图。
- **促进团队协作 (Promote Team Collaboration)
  促进团队协作（促进团队协作）**
  - 当团队所有成员都遵循同一套标准时，代码的合并、审查和交接会变得非常顺畅。
- **减少错误 (Reduce Errors)**
  - 统一的编码风格可以帮助避免一些由风格混淆引起的常见低级错误和逻辑陷阱。
- **提高维护性 (Improve Maintainability)
  提高维护性（提高可维护性）**
  - 结构清晰、风格一致的代码在未来更容易被修改、扩展功能或修复问题。
- **有助于代码审查 (Aid Code Review)**
  - 审查者可以更专注于代码的业务逻辑和安全性，而不用在代码风格的细枝末节上花费过多时间。
- **提高代码质量 (Improve Code Quality)**
  - 这是以上所有点的最终结果，是构建健壮、可靠、高质量软件项目的基石。
- **遵循行业标准 (Adhere to Industry Standards)
  遵循行业标准（遵守行业标准）**
  - 使你的代码更加专业，更容易被开源社区或行业接受和理解，尤其是在智能合约这样对安全和标准要求极高的领域。

## 文件命名

- **采用大驼峰命名法**
- **与合约组件名保持一致(interface\libray\contract)**
- **每一个文件只定义一个合约组件**
- **interface命名额外添加大写I作为前缀**



## 文件编排

不同类型的多合约文件可归类到不同的文件夹下

- interface->interfaces
- library->libraries
- 抽象合约->base/utils
- 主合约->contracts

## 合约的声明

- 第一行声明 SPDX-License-Identifier
- 第二行声明 pragma
  -  interface，library，抽象合约等建议声明兼容版本，比如^0.8.0
  - 需要部署的主合约建议固定版本
- import语句建议指定名称导入
- import 的第三方合约存在多个版本时建议指定版本号

## interface

- Errors -大驼峰 参数都用小驼峰
- Events-大驼峰  参数都用小驼峰
- Enums-大驼峰  参数也用大驼峰
- Structs-大驼峰  参数都用小驼峰
- Function-小驼峰  参数都用小驼峰
- 都是声明为external

当参数过长时，需要分行去展示

## library

- 是无状态的
- 以internal函数为主
- 也可以声明常量和errors
- 通常是对特定类型的扩展功能进行封装
- 可以携带storage的参数

## contract

- using for
- 状态变量
  - public 命名就正常采用小驼峰
  - private 前面加_ 在变量前面
- 常量
  - public 加下划线，以及大写，如果是一些数字的可以通过加下滑线来添加可读性 如100_000_000
  - private 一样的 下划线都是大写
- Events 事件 大驼峰
- Errors 大驼峰
- Modifier 小驼峰
- Functions 小驼峰  

### function

-  internal 表示内部函数，前面加_
- private 也是加_
- public ,external则正常表示

### 函数修饰符顺序

- **可见性 （external/public/internal/private）**
- **可变性（payable/view/pure）**
- **virtual**
- **override**
- **自定义modifier**

## 注释

- 良好的命名及注释

#### **@title**

- **含义**: 为合约或接口提供一个标题或名称。

- **适用范围**: `contract`, `interface`

- **示例**:

  ```
  /**
   * @title A simple storage contract
   */
  contract SimpleStorage {
      // ...
  }
  ```

#### **@author**

- **含义**: 标明合约的开发者。

- **适用范围**: `contract`, `interface`

- **示例**:

  ```
  /**
   * @title SimpleStorage
   * @author Jane Doe <jane.doe@example.com>
   */
  contract SimpleStorage {
      // ...
  }
  ```

#### **@notice**

- **含义**: **面向最终用户**的注释。用简单、非技术的语言解释合约或函数的作用。当用户与合约交互时（例如通过钱包），这些信息可能会展示给他们看。

- **适用范围**: `contract`, `interface`, `function`, `event`, `error`

- **示例**:

  ```
  /**
   * @notice Allows the owner to withdraw the entire balance of the contract.
   * Make sure you are the owner before calling this function.
   */
  function withdraw() external {
      // ...
  }
  ```

#### **@dev**

- **含义**: **面向开发者**的注释。用于解释实现细节、技术逻辑或任何开发者需要知道的额外信息。

- **适用范围**: `contract`, `interface`, `function`, `event`, `error`, `struct`, `enum`

- **示例**:

  Solidity

  ```
  /**
   * @dev This function uses the re-entrancy guard pattern to prevent attacks.
   * It transfers the contract's balance to the owner's address. 
   */
  function withdraw() external {
      // ...
  }
  ```

#### **@param**

- **含义**: 解释函数的参数。格式为 `@param <参数名> <参数说明>`。

- **适用范围**: `function`, `event`, `error`

- **示例**:

  ```
  /**
   * @notice Sets a new value for the stored data.
   * @dev Only the owner can call this function.
   * @param _newValue The new value to be stored.
   */
  function setValue(uint256 _newValue) external {
      // ...
  }
  ```

#### **@return**

- **含义**: 解释函数的返回值。格式为 `@return <返回值名/类型> <返回值说明>`。如果返回值没有命名，可以只写说明。

- **适用范围**: `function`

- **示例**:

  ```
  /**
   * @notice Gets the current stored value.
   * @return value The current value of the data.
   */
  function getValue() external view returns (uint256 value) {
      // ...
  }
  ```

#### **@inheritdoc**

- **含义**: **继承文档**。如果一个函数覆盖（override）了父合约或接口中的函数，使用这个标签可以自动将父函数的所有NatSpec注释复制过来。这可以减少重复编写相同的注释。

- **适用范围**: `function`

- **示例**:

  ```
  interface IValue {
      /**
       * @notice Gets the current stored value.
       * @return The current value.
       */
      function getValue() external view returns (uint256);
  }
  
  contract MyContract is IValue {
      /**
       * @inheritdoc IValue
       */
      function getValue() external view override returns (uint256) {
          return 42;
      }
  }
  ```

  这里 `MyContract.getValue` 会自动继承 `IValue.getValue` 的 `@notice` 和 `@return` 注释。

#### **@custom:...**

- **含义**: 自定义标签。用于一些非标准但你认为很重要的信息，例如标明测试用例、审计状态等。

- **适用范围**: 所有地方。

- **示例**:

  ```
  /**
   * @dev A critical function for fund management.
   * @custom:audit-status Passed on 2023-10-27
   * @custom:test-case test_withdraw_reverts_if_not_owner
   */
  function withdraw() external {
      // ...
  }
  ```

![image-20250928160528048](C:\Users\xk200\AppData\Roaming\Typora\typora-user-images\image-20250928160528048.png)

![image-20250928160540142](C:\Users\xk200\AppData\Roaming\Typora\typora-user-images\image-20250928160540142.png)



如果說要運行這個脚本，那麽我們一定要去在合於中添加注釋，@custom，并且，格式要如上



### 风格一：多行文档注释块 `/** ... */` (类似 Compound)



这种风格将一个函数或合约的所有 NatSpec 注释标签都包裹在一个 `/** ... */` 块中，非常像 JavaDoc 或 JSDoc 的风格。

**示例 (Compound 风格):**

Solidity

```
/**
 * @notice Sets a new favorite number for the caller
 * @dev This function validates that the new number is not zero.
 * It is an external function and can be called by anyone.
 * @param _newNumber The new favorite number to set.
 * @return success Returns true if the number was set successfully.
 */
function setFavoriteNumber(uint256 _newNumber) external returns (bool success) {
    require(_newNumber != 0, "Number cannot be zero");
    favoriteNumber[msg.sender] = _newNumber;
    return true;
}
```

**分析:**

- **优点**:
  1. **结构清晰，归属感强**: 关于一个函数的所有文档都被清晰地组织在一个“块”内，一目了然。当标签很多时（`@notice`, `@dev`, `@param`, `@return` 等），这种方式非常整洁。
  2. **易于阅读长描述**: 当 `@dev` 或 `@notice` 的描述特别长，需要换行时，这种块状结构的可读性更好。
  3. **传统且熟悉**: 对于有其他语言（如 Java, C#, JavaScript）背景的开发者来说，这种风格非常熟悉，易于上手。
- **缺点**:
  1. **代码冗余感**: 每一行前面都有一个 `*`，在注释内容较少时，会显得有些“重”，占用了较多的垂直空间。
- **适用场景**:
  - **复杂的函数**：当一个函数有多个参数、多个返回值，并且需要详细的 `@dev` 和 `@notice` 解释时，这种风格是最佳选择。
  - **合约级注释**：在合约或接口的顶部，使用这种方式来包含 `@title`, `@author`, `@notice` 等信息非常合适。

------



### 风格二：三斜线单行注释 `///` (类似 Uniswap)



这种风格为每一个 NatSpec 注释标签使用单独的一行 `///`。

**示例 (Uniswap 风格):**

Solidity

```
/// @notice Sets a new favorite number for the caller
/// @dev This function validates that the new number is not zero.
///      It is an external function and can be called by anyone.
/// @param _newNumber The new favorite number to set.
/// @return success Returns true if the number was set successfully.
function setFavoriteNumber(uint256 _newNumber) external returns (bool success) {
    require(_newNumber != 0, "Number cannot be zero");
    favoriteNumber[msg.sender] = _newNumber;
    return true;
}
```

*注：在 Uniswap V3 的代码中，他们甚至会为了极致的简洁而省略某些标签，比如当函数只有一个返回值时，可能直接写 `/// @return The new slot0 price` 而不写返回值名称。*

**分析:**

- **优点**:
  1. **简洁、轻量**: 每一行都是独立的，没有 `/**` 和 `*/` 的包裹，也没有行首的 `*`，看起来非常干净和紧凑。
  2. **灵活性高**: 可以在两行 `///` 注释之间插入普通的 `//` 注释，尽管这并不常见。
  3. **易于编辑**: 添加或删除一行注释非常简单，不需要调整整个注释块的结构。
- **缺点**:
  1. **关联性稍弱**: 当注释标签很多时，它们看起来像是一系列独立的行，而不是一个统一的注释块。对于习惯了块状注释的开发者来说，可能需要一点时间适应。
- **适用场景**:
  - **简单的函数**：当函数只有一个 `@notice` 或 `@dev` 解释，没有或只有一个参数时，这种风格非常高效。
  - **状态变量注释**：为单个状态变量添加简短的说明时，`/// @notice ...` 显得非常清爽。

------



### 总结与建议



| 特性       | 多行注释块 `/** ... */` (Compound 风格) | 三斜线 `///` (Uniswap 风格) |
| ---------- | --------------------------------------- | --------------------------- |
| **结构**   | 整体包裹，结构化强                      | 逐行独立，简洁轻量          |
| **可读性** | 复杂注释下更佳，易于概览                | 简单注释下更佳，代码更紧凑  |
| **适用性** | 复杂函数、合约级注释                    | 简单函数、状态变量注释      |
| **功能**   | **完全相同**                            | **完全相同**                |

Export to Sheets

**你应该如何选择？**

1. **没有绝对的对错**：首先要明确，这纯粹是**代码风格**的选择。Solidity 社区两者都广泛接受。
2. **一致性是关键**：**最重要的原则是，在你自己的项目或团队中，选择一种风格并始终坚持。** 混合使用会让代码看起来非常混乱。
3. **根据场景选择（我的个人建议）**：
   - **对于合约、接口级别的注释 (`@title`, `@author`)**：使用 `/** ... */` 块风格，因为它天生就是用来做“文件头”式声明的。
   - **对于函数**：
     - 如果函数逻辑复杂，有**超过2个标签**（例如，同时有 `@notice`, `@dev`, `@param`, `@return`），使用 `/** ... */` 块风格，可读性更好。
     - 如果函数很简单，只有**1-2个标签**（例如，只有一个 `@notice`），使用 `///` 行风格，代码更简洁。