# 绕过合约长度检查

### 1. 目标：为什么要去限制调用者类型？



在深入漏洞之前，我们先要明白开发者为什么会有这种需求：

- **防止机器人/脚本滥用**：在一些公平启动的项目中，如 NFT 铸造 (Mint) 或代币空投，项目方希望限制每个“人”只能参与一次。通过禁止合约调用，可以在一定程度上增加机器人批量操作的难度。
- **避免复杂的合约交互**：某些协议的设计可能没有考虑到被其他合约以复杂方式（如在一个交易中多次调用、结合闪电贷等）进行交互的情况，为了避免不可预见的风险，开发者可能会简单地禁止所有来自合约的调用。
- **确保某些操作的原子性**：开发者可能假设调用者是 EOA，从而认为函数调用是原子的，不会有重入等风险（这是一个危险的假设）。



### 2. 常用的检查方法（存在漏洞）



要判断一个地址是 EOA 还是合约账户，最常用、最直接的方法就是检查该地址上是否存在代码。以太坊虚拟机（EVM）提供了一个操作码 `EXTCODESIZE` 来获取地址的代码长度。

- **对于合约账户**：其代码长度 `extcodesize` **大于 0**。
- **对于 EOA 账户**：其代码长度 `extcodesize` **等于 0**（因为 EOA 没有代码）。

所以，一个常见的 `onlyEOA` 修饰符会这样写：

Solidity 坚固性

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract Target {
    string public message;
    
    // **有漏洞的检查修饰符**
    modifier onlyEOA() {
        // 使用 assembly 获取调用者的代码长度
        uint32 size;
        address caller = msg.sender;
        assembly {
            size := extcodesize(caller)
        }
        require(size == 0, "Only EOAs can call this function");
        _;
    }

    function sensitiveAction() public onlyEOA {
        message = "Action completed by an EOA.";
    }
}
```

这个 `onlyEOA` 修饰符看起来天衣无缝：检查调用者的代码长度，如果为0，就放行。那么，漏洞出在哪里呢？

------



### 3. 漏洞核心：合约的“诞生瞬间”



这个检查的漏洞源于一个关于合约生命周期的关键事实：

**一个智能合约的地址上出现代码，是在它的 `constructor` (构造函数) 执行完毕之后。**

换句话说，当一个合约正在执行其 `constructor` 逻辑时，它的 `extcodesize` **仍然是 0**！它就像一个正在“诞生”但还未完全成形的生命，在EVM的视角里，它此刻还没有“身体”（代码）。



### 4. 攻击方法：利用构造函数绕过检查



攻击者可以利用这一点，编写一个**攻击合约**，将恶意的调用逻辑放在 `constructor` 里面。

**攻击合约 (`Attacker.sol`)**

Solidity 坚固性

```
import "./Target.sol";

contract Attacker {
    // 构造函数：在部署本合约的瞬间被执行
    constructor(address targetAddress) {
        Target target = Target(targetAddress);

        // **关键攻击点**
        // 在 Attacker 合约的构造函数执行期间，
        // Attacker 地址的 extcodesize 仍然是 0。
        // 因此，对 Target.sensitiveAction() 的调用会成功绕过 onlyEOA 检查！
        target.sensitiveAction();
    }
}
```

**攻击流程：**

1. `Target` 合约已经部署在链上。
2. 攻击者部署 `Attacker` 合约，并将 `Target` 合约的地址作为参数传入 `Attacker` 的构造函数。
3. 在部署 `Attacker` 合约的这笔交易中，`Attacker` 的构造函数被执行。
4. 构造函数内部调用了 `Target.sensitiveAction()`。
5. `Target` 合约的 `onlyEOA` 修饰符开始检查 `msg.sender`（也就是 `Attacker` 合约的地址）的代码长度。
6. **由于 `Attacker` 合约还在构造过程中，`extcodesize(address(Attacker))` 返回 `0`！**
7. `require(size == 0)` 的检查通过，`sensitiveAction()` 被一个**合约账户**成功调用。检查被完美绕过。

------

### 5. 如何进行更可靠的检查和防御？

既然 `extcodesize` 不可靠，我们应该怎么办？

#### a. 方法一：检查 `tx.origin` (有争议)

一个更严格的检查方式是判断**交易的发起者 (`tx.origin`)** 和 **直接调用者 (`msg.sender`)** 是否为同一个地址。

- `tx.origin`：永远是发起这笔交易的 EOA 账户。
- `msg.sender`：是直接与本合约交互的地址。

如果一个合约A调用另一个合约B，那么对于B来说：

- `msg.sender` 是合约A的地址。
- `tx.origin` 是最初发起这笔交易的用户钱包地址。

所以，一个更强的检查可以是：

Solidity 坚固性

```
modifier trulyOnlyEOA() {
    // 检查直接调用者和交易发起者是否是同一个地址
    require(msg.sender == tx.origin, "Only EOAs can call this function");
    _;
}
```

**优点**：这个检查可以有效地阻止所有来自其他合约的调用（包括在构造函数中的调用）。

**巨大缺点 (为什么不推荐)**：

1. **破坏了合约的可组合性**：智能合约的魅力在于可以像乐高一样互相组合。这个检查会阻止所有合法的合约间调用。
2. **与智能合约钱包不兼容**：像 Gnosis Safe, Argent 这样的多签钱包和账户抽象钱包，其本身就是智能合约。使用这个检查，会导致这些高级钱包的用户完全无法与你的协议交互。这在未来的以太坊生态中是致命的。

#### b. 方法二：改变设计思路（推荐）

与其试图在技术上区分 EOA 和合约，不如从应用逻辑和经济模型上解决根本问题。

- **对于防机器人**：不要依赖链上检查。采用**白名单 (Whitelist)**、**验证码 (Captcha)**、**签名质询**等链下或半链下方案来验证用户身份。或者设计更好的经济模型，如**荷兰式拍卖**，让机器人没有套利空间。
- **对于防复杂交互**：不要一刀切地禁止合约。应该假设你的合约一定会被其他合约调用，并为此做好准备。例如，使用**重入锁 (`ReentrancyGuard`)** 来防止重入攻击，仔细设计协议的逻辑以抵御闪电贷等。

### 总结

| 方面               | 描述                                                         |
| ------------------ | ------------------------------------------------------------ |
| **问题**           | 如何限制函数只能被 EOA 调用，而不能被合约调用。              |
| **有漏洞的检查**   | `require(extcodesize(msg.sender) == 0)`                      |
| **绕过方法**       | 攻击者在自己的合约的 `constructor` 中调用目标函数，此时攻击合约的 `extcodesize` 为 0。 |
| **有争议的修复**   | `require(msg.sender == tx.origin)`。有效，但会与智能合约钱包不兼容，破坏可组合性。 |
| **推荐的解决方案** | **放弃在链上区分 EOA 和合约的执念。** 采用更健壮的应用层设计（如白名单、拍卖）或安全模式（如重入锁）来解决根本问题。 |