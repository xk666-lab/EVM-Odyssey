# 风险：低级调用

### 1. 两种调用方式：高级调用 vs. 低级调用



在智能合约中，与另一个合约交互主要有两种方式：

- **高级调用 (High-Level Calls)**：
  **高级调用（High-Level Calls）** ：
  - 这是我们最常用、最推荐的方式。
  - 语法：`OtherContract(contractAddress).someFunction(arg1, arg2);`
  - **关键特性**：这种调用方式是“全自动”和“安全的”。如果 `someFunction` 执行失败并 `revert`，这个 `revert` 会自动**传播 (propagate)** 回来，导致你当前函数的执行也立即失败并回滚。你不需要手动检查任何东西。
- **低级调用 (Low-Level Calls)**：
  **低级调用（Low-Level Calls）** ：
  - 这些是更底层的、更接近 EVM 操作码的函数，提供了更大的灵活性，但同时也带来了更大的风险。
  - 主要包括：**`.call()`**, **`.delegatecall()`**, **`.staticcall()`**, 以及现在**不推荐使用**的 **`.send()`** 和 **`.transfer()`**。
  - **关键特性**：这是漏洞的核心。当一个低级调用执行失败时，它**不会自动 `revert`**！相反，它会返回一个布尔值 `success` 来告诉你调用是否成功（通常 `success` 会是 `false`）。

**核心矛盾**：高级调用失败时会“大声喊叫”（revert），而低级调用失败时只会“小声嘀咕”（返回 a `false`）。如果你不去主动“听”这个结果，你的合约就会以为一切正常，并继续执行下去。

------



### 2. 未检查的低级调用：漏洞的根源



“未检查的低级调用”漏洞，就是指开发者使用了 `.call()`, `.send()` 等低级函数，但**没有检查它们返回的 `success` 布尔值**。

合约会天真地认为外部调用已经成功，并继续执行后续的逻辑（例如更新状态变量），但这与链上的实际情况完全不符，导致合约状态出现严重的不一致。



### 3. 低级调用函数详解与风险



- **`address.call(bytes memory data)` -> `(bool success, bytes memory data)`**
  - **功能**：最通用、最强大的低级调用。可以用来发送 ETH，也可以调用目标合约的任意函数。
  - **风险**：如果你不检查返回的 `success`，当调用失败时，你的合约会毫不知情地继续执行。这是最常见的漏洞来源。
- **`address.send(uint256 amount)` -> `(bool success)` (不推荐使用)**
  - **功能**：一个专门用来发送 ETH 的函数。
  - **风险**：
    1. **同样需要检查返回值**。`someAddress.send(1 ether);` 这样写是**极其危险的**。
    2. **固定 Gas 津贴**：`send` 只提供 2300 Gas 用于执行。如果接收方是一个合约，并且其 `receive()` 或 `fallback()` 函数的逻辑稍微复杂一点（例如，写入一个存储变量），Gas 就会不够用，导致 `send` 失败。这会使你的合约无法与某些合约交互。
- **`address.transfer(uint256 amount)` (不推荐使用)**
  - **功能**：也是专门用来发送 ETH 的。
  - **与 `send` 的区别**：`.transfer()` 在失败时会自动 `revert`。从这个角度看，它比 `send` 安全。
  - **风险**：它和 `send` 一样，也只有 2300 Gas 的津贴，同样存在与复杂合约交互失败的问题。随着未来 Gas 成本的变化，依赖固定 Gas 的函数都是脆弱的。

**现代最佳实践**：当需要发送 ETH 时，**应该使用 `.call()`**。 `(bool success, ) = payable(recipientAddress).call{value: amount}("");` `require(success, "Failed to send Ether");` 这种方式会转发所有可用的 Gas，更加健壮和面向未来。

------

### 4. 攻击场景实例

假设有一个多方参与的众筹合约，项目失败后，用户可以取回自己的投资。

**有漏洞的代码 👎**

```
contract UnsafeCrowdfund {
    mapping(address => uint256) public contributions;

    // ... 其他函数 ...

    function refund() public {
        uint256 amount = contributions[msg.sender];
        require(amount > 0, "No contribution to refund.");

        // **漏洞点**：使用了 .send() 但没有检查其返回值
        payable(msg.sender).send(amount);

        // 无论 send 是否成功，代码都会继续执行到这里
        contributions[msg.sender] = 0;
    }
}
```

**攻击/利用方式：**

1. 攻击者创建一个**恶意合约 (`Attacker.sol`)**，并确保其 `receive()` 函数会消耗超过 2300 Gas（例如，在函数里写入一个存储变量）。
2. 攻击者使用这个 `Attacker` 合约地址参与了 `UnsafeCrowdfund` 的众筹。
3. 众筹失败后，攻击者调用 `refund()` 函数来取回资金。
4. `UnsafeCrowdfund` 合约执行 `payable(msg.sender).send(amount);`。
5. 由于 `Attacker` 合约的 `receive()` 函数需要大量 Gas，`send` 操作因为 Gas 不足而**失败**，返回 `false`。
6. 然而，`UnsafeCrowdfund` 合约**没有检查这个返回值**，它错误地认为退款已经成功。
7. 代码继续执行 `contributions[msg.sender] = 0;`。
8. **后果**：攻击者的资金**从未被真正退还**，但他在众筹合约中的余额记录已经被清零。这笔钱被永久地锁在了 `UnsafeCrowdfund` 合约中，攻击者遭受了资金损失。如果合约有其他逻辑漏洞，这笔“无人认领”的资金还可能被合约所有者提走。

------

### 5. 如何修复和防范

修复方法非常直接，并且是所有智能合约开发者必须遵守的黄金法则。

1. **永远检查低级调用的返回值**
   - 必须用一个布尔变量接收返回值，并立即用 `require` 来断言其结果。
2. **使用 `call` 来发送 ETH**
   - 放弃 `send` 和 `transfer`，拥抱更现代、更健壮的 `call` 方式。
3. **遵循“检查-生效-交互”模式 (Checks-Effects-Interactions)**
   - 这能同时防范此漏洞和重入攻击。先更新状态，再进行外部调用。

**安全的代码 👍**

Solidity 坚固性

```
contract SafeCrowdfund {
    mapping(address => uint256) public contributions;

    // ... 其他函数 ...

    function refund() public {
        // 1. 检查 (Checks)
        uint256 amount = contributions[msg.sender];
        require(amount > 0, "No contribution to refund.");

        // 2. 生效 (Effects) - 先更新状态
        contributions[msg.sender] = 0;

        // 3. 交互 (Interactions) - 最后进行外部调用，并严格检查返回值
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success, "Failed to send Ether");
    }
}
```

## 预防办法

你可以使用以下几种方法来预防未检查低级调用的漏洞：

1. 检查低级调用的返回值，在上面的银行合约中，我们可以改正 `withdraw()`。

   ```
   bool success = payable(msg.sender).send(balance);
   require(success, "Failed Sending ETH!")
   ```

合约转账`ETH`时，使用 `call()`，并做好重入保护。

使用`OpenZeppelin`的[Address库](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol)，它将检查返回值的低级调用封装好了。

**总结：** 低级调用是 Solidity 给予开发者的“底层权限”，它功能强大但也伴随着巨大的责任。最核心的责任就是**必须手动处理调用失败的情况**。忽略低级调用的返回值，就等于在合约中埋下了一颗定时炸弹，随时可能因为外部合约的意外行为而导致自身状态错乱，引发资金损失或其他逻辑崩溃。