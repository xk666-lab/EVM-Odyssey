# 选择器碰撞攻击 (Function Selector Collision)

> 💡 **核心要点**
> - 函数选择器只有 4 字节，容易碰撞
> - 代理合约模式下风险极大
> - 需要扫描检测碰撞
> - 使用透明代理模式或钻石代理

---

## 📚 目录

1. [什么是函数选择器](#1-什么是函数选择器)
2. [什么是选择器碰撞](#2-什么是选择器碰撞)
3. [风险与攻击场景](#3-风险与攻击场景)
4. [防范方法](#4-防范方法)
5. [解决方案](#5-解决方案)

---

## 1. 什么是函数选择器？

### 1.1 核心概念

当你通过 Ethers.js, Web3.js 或其他工具与一个智能合约交互时，你提供的调用数据 (calldata) 并不是明文的函数名。为了节省 Gas 和空间，以太坊虚拟机 (EVM) 使用一个简短的标识符来区分函数，这个标识符就是**函数选择器**。

### 1.2 生成过程

1. **获取函数签名 (Function Signature)**：将函数名和其参数类型（不含参数名和空格）拼接成一个字符串
   - 例如：`transfer(address,uint256)`

2. **进行 Keccak-256 哈希**：对这个签名字符串进行 Keccak-256 哈希计算

3. **截取前4个字节**：取哈希结果的前4个字节（即8个十六进制字符），这就是该函数的选择器

### 1.3 示例

```
transfer(address,uint256)
→ Keccak-256 哈希 
→ 0xa9059cbb2ab09eb219583f4a59a5d0623ade346d962bcd4e46b11da047c9049b
→ 截取前4字节
→ 函数选择器为 0xa9059cbb
```

---

## 2. 什么是选择器碰撞？

### 2.1 问题根源

Keccak-256 的完整哈希值有32字节长，几乎不可能发生碰撞。但是，函数选择器只取了**前4个字节**。

这意味着我们把一个巨大的信息空间（2^256）压缩到了一个相对较小的空间里（2^32，约42亿）。

根据鸽巢原理，当函数签名的数量足够多时，**必然会存在两个或多个不同的函数签名，它们哈希后的前4个字节是完全相同的**。

### 2.2 碰撞示例

```solidity
// 函数签名 1
"process(uint256)"
→ Keccak-256 → 0x494467551a3534b1e582b3a968a1825c56b78c66a80fd9d2499a4413344189e3
→ 选择器 → 0x49446755

// 函数签名 2
"mint(uint256,address)"
→ Keccak-256 → 0x4944675550346a8c43093158ce554581f28b7f8f60a28f8f2b7b51e44f509c69
→ 选择器 → 0x49446755
```

`process(uint256)` 和 `mint(uint256,address)` 这两个完全不同的函数，拥有完全相同的函数选择器 `0x49446755`。

---

## 3. 风险与攻击场景

### 3.1 代理合约模式下的危险

在单个合约中，编译器通常不允许存在两个选择器相同的函数，所以直接的风险较小。然而，当涉及到**代理合约 (Proxy Contracts)** 和 **`delegatecall`** 时，选择器碰撞就变得极其危险。

#### 代理合约模式

- **代理合约 (Proxy)**: 存储数据，包含升级逻辑，通常还有一个 `owner` 或 `admin`
- **逻辑合约 (Implementation)**: 包含业务逻辑代码

#### 危险之处

如果用户想调用的**逻辑合约**中的某个函数，其选择器恰好与**代理合约**自身的某个管理函数（例如 `upgradeTo(address)`) 发生碰撞，会发生什么？

### 3.2 攻击实例

假设存在以下碰撞：

- 逻辑合约中有一个**公开的业务函数**：`doSomething()`，其选择器为 `0x12345678`
- 代理合约中有一个**仅限管理员调用的管理函数**：`destroyProxy()`，其选择器也恰好是 `0x12345678`

#### 攻击流程

1. 一个普通用户（非管理员）调用代理合约，想执行业务功能 `doSomething()`。他发送的 `calldata` 前4字节是 `0x12345678`
2. 代理合约收到这个调用。它的分发逻辑首先检查："这个 `0x12345678` 是不是要调用我自己的函数？"
3. 代理合约发现，`0x12345678` 匹配到了它自己的 `destroyProxy()` 函数
4. 如果权限检查被绕过或放松，代理合约执行了 `destroyProxy()`，而不是将调用转发给逻辑合约
5. 结果可能是合约被销毁，所有资产丢失或被锁定

### 3.3 真实案例

**Art Gobblers**：在 `Art Gobblers` 合约中，其 `draw(uint256,address)` 函数的选择器与 `setApprovalForAll(address,bool)` 的选择器发生了碰撞。这导致了一个潜在的漏洞，虽然没有被利用，但迫使团队重新部署了合约。

---

## 4. 防范方法

### 4.1 使用自动化工具检测

有一些专门的工具可以扫描你的合约，找出所有公开和外部函数的选择器，并检查是否存在碰撞。

#### 工具推荐

- **Solmate**: 提供了一个名为 `SelectorClash.sol` 的脚本
- **Foundry/Hardhat**: 可以在测试套件中集成自定义的碰撞检测逻辑

### 4.2 开发中保持警惕

- 当你编写或审计使用代理模式的合约时，必须将代理合约和所有潜在的逻辑合约放在一起进行整体分析
- 手动或通过脚本列出所有函数的选择器，并进行对比
- **特别注意**：代理合约中**任何 `public` 或 `external` 函数**（包括从父合约继承来的）都可能成为碰撞的目标

### 4.3 避免易碰撞的函数签名

- 函数名和参数尽量取得有意义且具体，避免过于简单（如 `execute()` `run()`）或通用的命名
- 例如，将 `process(uint256)` 改为 `processBatch(uint256 batchId)` 会生成一个完全不同的选择器

---

## 5. 解决方案

### 5.1 修改函数签名（最直接）

这是最简单、最根本的解决方案。

#### 具体操作

- **更改函数名**：`myFunction(uint256)` → `_myFunction(uint256)`
- **更改参数类型或数量**：`process(uint256)` → `process(uint256, bool)`
- **更改参数顺序**：`update(address, uint256)` → `update(uint256, address)`

#### 优点

- 简单明了，从根源上消除了碰撞
- 无任何运行时开销 (Gas cost)

### 5.2 使用安全的代理模式

#### 透明代理模式 (Transparent Proxy Pattern)

**原理**：
- 如果 `msg.sender` 是管理员 (admin)，那么调用**只能**匹配代理合约自身的管理函数
- 如果 `msg.sender` 是普通用户，那么调用**只能**被 `delegatecall` 到逻辑合约

**效果**：
- 为管理员和用户创建了完全隔离的"命名空间"
- 即使选择器发生碰撞，因为调用者的身份不同，也绝不会调用到错误的函数

```solidity
// OpenZeppelin 透明代理示例
contract TransparentProxy {
    address public admin;
    address public implementation;
    
    modifier ifAdmin() {
        if (msg.sender == admin) {
            _;
        } else {
            _fallback();
        }
    }
    
    function upgradeTo(address newImplementation) external ifAdmin {
        implementation = newImplementation;
    }
    
    function _fallback() internal {
        // delegatecall to implementation
    }
}
```

#### 钻石代理模式 (Diamond Proxy, EIP-2535)

**原理**：
- 钻石代理维护一个从"函数选择器"到"逻辑合约地址（Facet）"的显式映射
- 当一个调用进来时，它会查找这个映射表，找到该选择器对应的具体逻辑合约地址

**效果**：
- 每个选择器都必须被显式地注册和映射
- 在注册时就可以检查是否存在冲突
- 提供了更细粒度的控制

### 5.3 合约升级（部署后补救）

如果一个存在选择器冲突的合约已经被部署，并且它是可升级的：

1. **部署修复后的逻辑合约**：创建一个新版本的逻辑合约，在其中修改冲突的函数签名
2. **执行升级**：由代理合约的管理员调用 `upgradeTo()`
3. **完成迁移**：所有后续的调用都会被转发到新的逻辑合约

---

## 📚 学习资源

### 官方文档
- [EIP-2535 Diamond Proxy](https://eips.ethereum.org/EIPS/eip-2535)
- [OpenZeppelin Proxy Patterns](https://docs.openzeppelin.com/contracts/4.x/api/proxy)

### 工具
- [Solmate SelectorClash](https://github.com/transmissions11/solmate)
- [Foundry](https://book.getfoundry.sh/)

---

## ✅ 学习检查清单

完成本章节后，确认你已经：

- [ ] 理解了函数选择器的生成过程
- [ ] 知道为什么会发生选择器碰撞
- [ ] 理解了代理合约下的碰撞风险
- [ ] 会使用工具检测碰撞
- [ ] 知道透明代理和钻石代理的区别
- [ ] 能够修改函数签名避免碰撞

---

## 🎯 下一步

1. ✅ 使用 Foundry 编写碰撞检测测试
2. ✅ 学习 **抢先交易/MEV** → `03-抢先交易MEV/`
3. ✅ 更新你的 `PROGRESS.md`

---

**记住**：
- ✅ **在部署前检测碰撞**
- ✅ **使用安全的代理模式**
- ✅ **避免简单的函数名**
- ✅ **定期审计代理+逻辑合约**

祝你学习顺利！🚀

